/' PlantUML diagrams for the herbivory module.
 ' author: Wolfgang Pappa, Senckenberg BiK-F
 ' date: August 2017
 ' 
 ' PlantUML is free software under the GPL license.
 ' See http://plantuml.com 
 '/

@startuml (id=basic_components)
	[Herbivory Module] as herbivory
	() "Fauna::ParamReader" as paramreader
	() "Fauna::PatchHabitat" as patchhabitat
	() "GuessOutput::HerbivoryOutput" as herbivoutput
	node "Herbivory Output Files" as outputfiles
	[LPJ-GUESS Vegetation Model] as guess
	node "Instruction Files" as insfiles
	guess        <..  patchhabitat
	patchhabitat  --  herbivory
	herbivory     --  herbivoutput 
	herbivoutput  ..> outputfiles : write
	herbivory     --  paramreader 
	paramreader   ..> insfiles  : read
@enduml

@startuml (id=exception_classes)
	namespace std{
		hide members
		hide methods
		exception <|-- logic_error
		exception <|-- runtime_error
		logic_error <|-- invalid_argument
		logic_error <|-- out_of_range 
	}
@enduml

@startuml (id=forage_classes)
	hide members
	hide methods
	namespace Fauna{
		class ForageBase{
			digestibility
			mass
		}
		show ForageBase members
		class GrassForage{
			fpc
			sward_density
		}
		show GrassForage members
		ForageBase <|-- GrassForage
		class HabitatForage
		HabitatForage *->GrassForage
		enum ForageValueType{
			POSITIVE_AND_ZERO
			ZERO_TO_ONE
		}
		show ForageValueType members
		class ForageValues< ForageValueType >
		ForageValueType -- ForageValues
		enum ForageType{
			FT_GRASS,
			FT_INEDIBLE
		}
		show ForageType members
	}
@enduml

@startuml (id=herbivore_classes)
	hide members
	hide methods
	namespace Fauna {
		interface HerbivoreInterface
		interface PopulationInterface
		abstract HerbivoreBase
		HerbivoreInterface  <|-- HerbivoreBase
		HerbivoreBase       <|-- HerbivoreIndividual
		HerbivoreBase       <|-- HerbivoreCohort
		PopulationInterface <|-up- IndividualPopulation
		PopulationInterface <|-up- CohortPopulation
		HerbivoreIndividual "*" <--* "1" IndividualPopulation
		HerbivoreCohort     "*" <--* "1" CohortPopulation
		HerbivoreIndividual  <..  IndividualPopulation : <<create>>
		(HerbivoreIndividual, IndividualPopulation) .. CreateHerbivoreIndividual
		HerbivoreCohort      <..  CohortPopulation     : <<create>>
		(HerbivoreCohort, CohortPopulation) .. CreateHerbivoreCohort
	}
@enduml

@startuml (id=herbivorebase_compartments)
	hide members
	hide methods
	namespace Fauna{
	abstract HerbivoreBase{
		-Hft hft
		-int age_days
	}
	show HerbivoreBase members
	class FatmassEnergyBudget{
		|catabolize_fat()
		|metabolize_energy()
		-double energy_needs
		-double fatmass
		-double max_fatmass
	}
	show FatmassEnergyBudget members
	show FatmassEnergyBudget methods
	HerbivoreBase *-up-> "1" FatmassEnergyBudget
	package "Forage Energy" <<rectangle>> {
		interface GetNetEnergyContentInterface <<strategy>>
		GetNetEnergyContentInterface <|-- GetNetEnergyContentDefault
	}
	HerbivoreBase *-up-> "1" "Forage Energy"
	package "Reproduction" <<rectangle>> {
    class ReprIlliusOconnor2000
	}
	HerbivoreBase .up.> "1" "Reproduction"
	package "Diet" <<rectangle>> {
		interface ComposeDietInterface <<strategy>>
		ComposeDietInterface <|-- PureGrazerDiet
	}
	HerbivoreBase  .up.> "1" "Diet"
	package "Energy Expenditure" <<rectangle>>  {
		annotation "get_expenditure_taylor_1981()"
	}
	HerbivoreBase  ..> "1" "Energy Expenditure"
	package "Foraging Limits" <<rectangle>>  {
		class GetDigestiveLimitIllius1992 <<functor>>
		class GetHalfMaxForagingLimit     <<functor>>
	} 
	HerbivoreBase  ..> "*" "Foraging Limits"
	package "Mortality" <<rectangle>> {
		class GetBackgroundMortality           <<functor>>
		class GetStarvationMortalityIllius2000 <<functor>>
		class GetStarvationMortalityThreshold  <<functor>>
		class GetSimpleLifespanMortality       <<functor>>
	}
	HerbivoreBase ..> "*" "Mortality"
	}
@enduml

@startuml (id=important_classes)
	hide members
	hide methods

	namespace Fauna{
		class Simulator
		abstract Habitat
		interface HerbivoreInterface 
		class Hft
		interface PopulationInterface
		Simulator            ..> SimulationUnit : <<use>>
		class SimulationUnit
		SimulationUnit      *--> "1" Habitat
		SimulationUnit      *--> "*" PopulationInterface : contains >
		class HftPopulationsMap
		(SimulationUnit, PopulationInterface) .. HftPopulationsMap
		PopulationInterface *--> "*" HerbivoreInterface
		HerbivoreInterface   --> "1" Hft
	}
@enduml

@startuml (id=new_forage_type)
	namespace Fauna{
		class ParamReader
		enum ForageType {
			FT_GRASS,
			FT_NEWFORAGE
		}
		ParamReader   ..> ForageType : <<use>>
		class ForageValues< ForageValueType >
		ForageValues ..> ForageType : <<use>>
		abstract ForageBase
		class NewForage{
			your_custom_members
		}
		NewForage <|-- ForageBase
		class HabitatForage{
			get_total()
			merge()
		}
		HabitatForage *--> NewForage
		abstract HerbivoreBase
		HerbivoreBase ..> HabitatForage : <<use>>
		interface GetDigestibility
		class PatchHabitat{
			get_available_forage()
			reduce_forage_mass()
		}
		PatchHabitat ..> HabitatForage : <<use>>
	}
	FaunaSim.SimpleHabitat  ..> Fauna.HabitatForage : <<use>>
	class Individual{
		get_forage_mass()
	}
	Fauna.PatchHabitat          ..> Individual       : <<use>>
	Fauna.GetDigestibility      ..> Individual       : <<use>>
	GuessOutput.HerbivoryOutput ..> Fauna.NewForage  : <<use>>
@enduml

@startuml (id=new_herbivore_type)
	namespace Fauna{
		hide members
		hide methods
		interface HerbivoreInterface
		abstract HerbivoreBase
		HerbivoreInterface  <|-- HerbivoreBase
		HerbivoreBase       <|-- HerbivoreIndividual
		HerbivoreBase       <|-- HerbivoreCohort
		HerbivoreInterface  <|-- NewHerbivore
		interface PopulationInterface
		PopulationInterface <|-- NewPopulation
		NewPopulation        ..> NewHerbivore : create & manage
	}
@enduml

@startuml (id=net_energy_content)
	hide members
	hide methods
	namespace Fauna{
		enum NetEnergyModel{
			NM_DEFAULT
		}
		Hft *--> NetEnergyModel
		interface GetNetEnergyContentInterface <<strategy>>
		GetNetEnergyContentInterface <|-- GetNetEnergyContentDefault
		abstract HerbivoreBase
		HerbivoreBase ..> GetNetEnergyContentInterface : <<create>>
	}
@enduml

@startuml (id=outputclasses)
	hide methods
	hide members
	namespace FaunaOut{
		class HerbivoreData
		class HabitatData
		class CombinedData
		CombinedData o-> "*" HerbivoreData
		note on link : by HFT
		CombinedData o-> "1" HabitatData
	}
@enduml

@startuml (id=outputmodule_class)
	hide members 
	annotation "Output Directory" as outputdirectory 
	namespace GuessOutput{
		class HerbivoryOutput <<singleton>>
		abstract OutputChannel
		HerbivoryOutput     --> OutputChannel : <<use>> >
		abstract OutputModule
		OutputModule      <|--  HerbivoryOutput
		OutputChannel     <|--  FileOutputChannel
		FileOutputChannel   --> .outputdirectory : write >
		enum interval {
			DAILY
			MONTHLY
			ANNUAL
			DECADAL
		}
		show interval members
		HerbivoryOutput *-- interval
		note on link : nested
	}
	namespace Fauna{
		interface HerbivoreInterface
		abstract Habitat
	}
	namespace FaunaOut{
		class CombinedData
	}
	GuessOutput.HerbivoryOutput ..> Fauna.Habitat : retrieve_output() >
	GuessOutput.HerbivoryOutput ..> Fauna.HerbivoreInterface : retrieve_output() >
	GuessOutput.HerbivoryOutput ..> FaunaOut.CombinedData : <<use>> >
@enduml

@startuml (id=outputmodule_initialization)
	skinparam sequenceParticipant underline
	participant "framework()" as framework
	participant ":OutputModuleModuleRegistry" as OutputModuleModuleRegistry
	participant ":OutputModuleContainer" as OutputModuleContainer
	participant ":HerbivoryOutput" as HerbivoryOutput <<Singleton>>
	participant ":FileOutputChannel" as FileOutputChannel
	activate OutputModuleModuleRegistry
	[-> OutputModuleModuleRegistry : register_output_module("herbivory")
	[-> framework : start guess
	== initialization ==
	framework -> OutputModuleContainer : create
	activate OutputModuleContainer
	framework -> OutputModuleModuleRegistry : create_all_modules()
	OutputModuleModuleRegistry -> HerbivoryOutput : create
	activate HerbivoryOutput
	note over HerbivoryOutput : declare parameters
	note over framework : read parameters
	framework -> OutputModuleContainer : init()
	OutputModuleContainer      -> FileOutputChannel : create
	activate FileOutputChannel
	OutputModuleContainer -> HerbivoryOutput : init()
	framework -> HerbivoryOutput : set_hftlist()
	framework -> HerbivoryOutput : set_include_date()
	== simulation ==
	loop "simulation days"
		framework -> OutputModuleContainer : outdaily(gridcell)
		OutputModuleContainer -> HerbivoryOutput : outdaily(gridcell)
		loop "table column"
			HerbivoryOutput -> FileOutputChannel : add_value()
		end loop
	end loop
@enduml

@startuml (id=patchhabitat_construction)
	skinparam sequenceParticipant underline
	participant "framework()" as framework
	participant ":Fauna::Simulator" as simulator
	participant ":Fauna::PatchHabitat" as patchhabitat
	participant ":Fauna::HftPopulationsMap" as populations
	participant ":Gridcell" as gridcell
	participant ":Patch" as patch
	framework    -> simulator : <<create>>
	activate simulator

	framework    -> gridcell : <<create>>
	activate gridcell
	
	gridcell     -> patch : <<create>>
	activate patch

	framework    -> simulator : create_digestibility_model()
	framework  <--  simulator : digestibility_model

	framework    -> patchhabitat : <<create>> (digestibility_model)
	note right : constructor injection
	activate patchhabitat

	framework    -> simulator : create_populations()
	simulator    -> populations : <<create>>
	activate populations

	framework  <--  simulator : populations

	note over framework : combine habitat and populations in a SimulationUnit

	framework    -> patch : set_herbivory_unit(SimulationUnit)
	note right : setter injection
@enduml

@startuml (id=patchhabitat_interactions)
	hide members
	hide methods
	class Pft
	class Individual
	class Patch
	class Stand
	class Gridcell
	Gridcell "1" *--> "*" Stand
	Stand    "1" *--> "*" Patch
	Patch    "1" *--> "*" Individual
	Individual    --> Pft

	namespace Fauna{
		abstract Habitat
		class SimulationUnit
		SimulationUnit *-down-> Habitat
		class PatchHabitat
		Habitat <|-down- PatchHabitat
		interface GetDigestibility
		PatchHabitat *-> "1" GetDigestibility
		class PftParams
	}

	Patch *-> Fauna.SimulationUnit : owns >
	Fauna.PatchHabitat -> Patch : <<use>>
	Pft *-left-> Fauna.PftParams
@enduml

@startuml (id=parameters_access)
	hide members
	hide methods
	namespace Fauna{
		CreateHerbivoreIndividual ..> Parameters
		CreateHerbivoreIndividual ..> Hft
		CreateHerbivoreCohort     ..> Parameters
		CreateHerbivoreCohort     ..> Hft
		Simulator                 ..> Parameters
		Simulator                 ..> Hft
		PatchHabitat              ..> PftParams
		CohortPopulation          .up.> Hft
		IndividualPopulation      .up.> Hft
		abstract HerbivoreBase
		HerbivoreBase             .up.> Hft
	}
	namespace FaunaSim{
		Framework                 ..> Fauna.Parameters
		Framework                 ..> Fauna.Hft
	} 
@enduml

@startuml (id=parameters_classes)
	hide members
	hide methods
	annotation "framework()"       as framework
	annotation "Instruction Files" as insfiles
	annotation "plib.h"            as plib
	annotation "parameters.h"      as parameters
	class "FaunaSim.Framework" <<singleton>>
	class "Fauna.ParamReader"   <<singleton>>
	Pft                "1" *-- "1" Fauna.PftParams
	framework           ..> Fauna.ParamReader : <<use>>
	parameters          ..> Pft               : <<use>>
	GuessOutput.HerbivoryOutput     ..> parameters        : <<use>>
	parameters          ..> plib              : <<use>>
	plib                ..> insfiles          : <<read>>
	framework           ..> parameters        : <<use>>
	namespace Fauna {
		ParamReader  <..> .parameters : <<call>>
		ParamReader   ..> .plib       : <<call>>
		ParamReader   ..> Hft         : <<create>>
		ParamReader   ..> PftParams   : <<call>>
		ParamReader   ..> Parameters  : <<create>>
		class Hft {
			|is_valid()
		}
		show Hft methods
		class Parameters {
			|is_valid()
		}
		show Parameters methods
		class PftParams {
			|is_valid()
		}
		show PftParams methods
	}
	FaunaSim.Framework ..> Fauna.ParamReader : <<use>>
@enduml

@startuml (id=population_classes)
	hide members
	hide methods
	namespace Fauna{
		interface PopulationInterface
		PopulationInterface <|-- IndividualPopulation
		PopulationInterface <|-- CohortPopulation
		IndividualPopulation *-- "*" HerbivoreIndividual
		CohortPopulation     *-- "*" HerbivoreCohort
		class SimulationUnit
		SimulationUnit *-- "*" PopulationInterface
		(SimulationUnit, PopulationInterface) .. HftPopulationsMap
		abstract Habitat
		SimulationUnit *-- "1" Habitat
	}
@enduml

@startuml (id=testsim_classes)
	hide members
	hide methods 
	annotation "parameters.h" as parameters 
	namespace FaunaSim {
		class "Framework" <<singleton>>
		class HabitatGroup
		class HabitatGroupList
		HabitatGroupList *-> "*" HabitatGroup
		class SimpleHabitat
		class LogisticGrass
		SimpleHabitat *-> LogisticGrass
	}
	namespace Fauna {
		class "ParamReader"   <<singleton>>
		abstract Habitat 
		Simulator     ..> Habitat                        : <<call>>
		SimulationUnit *-> Habitat
	}
	FaunaSim.HabitatGroup *--> "*" Fauna.SimulationUnit
	FaunaSim.SimpleHabitat --|> Fauna.Habitat
	FaunaSim.Framework ..> Fauna.ParamReader              : <<use>>
	FaunaSim.Framework .up.> .parameters                    : <<use>>
	FaunaSim.Framework ..> Fauna.Simulator                : <<create>>
	FaunaSim.Framework *-left-> "1" .GuessOutput.HerbivoryOutput   
	FaunaSim.Framework .left.> .GuessOutput.FileOutputChannel : <<create>>
	FaunaSim.Framework ..> "*" FaunaSim.HabitatGroup      : <<create>>
	annotation "main()" as main
	main .down.> FaunaSim.Framework : <<call>>
@enduml

@startuml (id=testsim_sequence)
	participant "main()" as main
	participant "plib.h" as plib
	participant "FaunaSim::Framework" as Framework <<singleton>>
	participant "Fauna::ParamReader" as ParamReader <<singleton>>
	participant "Fauna::Simulator" as Simulator
	participant "GuessOutput::HerbivoryOutput" as HerbivoryOutput <<singleton>>
	== initialization ==
	main -> Framework : <<create>>
	activate Framework
	activate HerbivoryOutput
	Framework -> plib : declare parameters
	main -> plib : read instruction file
	plib -> ParamReader : call indirectly
	activate ParamReader
	plib -> Framework : plib_callback()
	main <-- ParamReader : Fauna::Parameters
	main <-- ParamReader : Fauna::HftList
	main -> Framework : run()
	Framework -> HerbivoryOutput : set_hftlist()
	Framework -> HerbivoryOutput : init()
	Framework -> Simulator : <<create>>
	activate Simulator
	note over Framework : create habitats
	== simulation ==
	loop YEARS: nyears
		loop DAYS: 365
			loop HABITAT GROUPS: nhabitat_groups
				loop HABITATS: nhabitats_per_group
					Framework -> Simulator : simulate_day()
					Framework -> HerbivoryOutput : outdaily()
				end
			end
		end
	end
	== end of simulation ==
	deactivate Simulator
	Framework --> main
	deactivate HerbivoryOutput
	deactivate Framework
@enduml
